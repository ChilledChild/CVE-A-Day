from datetime import datetime
import random
import tweepy
import csv

consumer_key = "xxxxxxxxxxxxxxxx"
consumer_secret = "xxxxxxxxxxxxxxxx"
access_token = "xxxxxxxxxxxxxxxx"
access_token_secret = "xxxxxxxxxxxxxxxx"
auth = tweepy.OAuthHandler(consumer_key, consumer_secret)
auth.set_access_token(access_token, access_token_secret)
api = tweepy.API(auth)

# Logging variables
timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")[:-3]
logger = open('history_log.txt', 'a', encoding='utf-8')
tweeted = open('tweeted_cve.txt', 'a', encoding='utf-8')

logger.write(timestamp + " Script has started!\n")

# Verify API credentials
try:
    api.verify_credentials()
    print("Authentication OK")
    logger.write(timestamp + " Authentication OK!\n")
except tweepy.TweepError:
    print("Error during authentication")
    logger.write(timestamp + " Error during authentication.\n")


# Check if a string exists in a specified file
def check_if_string_in_file(file_name, string_to_search):
    with open(file_name, 'r') as read_obj:
        for line in read_obj:
            if string_to_search in line:
                return string_to_search
    return False


# Break apart the CVE entry row
content = [[]]
with open('allitems.csv', newline='', encoding='utf-8', errors='ignore') as csvfile:
    csv_reader = csv.reader(csvfile, delimiter=',', quotechar='"')
    included_cols = [0, 2]

    # Create the SVC object
    for row in csv_reader:
        item = [row[0], row[2]]
        content.append(item)


def setranditems():
    randitem = ['', '']
    while randitem[0] == '' or randitem[1] == '':
        randitem = random.choice(content)
    return randitem[0], randitem[1]


# Create CVE tweet assets
web_link = "https://www.cvedetails.com/cve/"
tweet_max_len = 280

# Create Tweepy API variables
user_id = "CVE_A_Day"
recipient_id = "xxxxxxxxxx"
count = 1
auto_populate_reply_metadata = True


# Break apart tweet_head text to fit tweet max characters.
def tweet_breaker(tweet_head):
    to_tweet = []
    tweets = []
    item = ""
    test = 0
    first = True
    for char in tweet_head:
        if first:
            item += char
            test += 1
            first = False
        else:
            if test % (tweet_max_len - 1) == 0:
                item += char
                to_tweet.append(item)
                test += 1
                item = "@CVE_A_DAY "
                test += 11
            else:
                item += char
                test += 1
        first = False
    to_tweet.append(item)
    print("Formatted Tweet Count:", len(to_tweet), [len(x) for x in to_tweet])
    return to_tweet


# See if the CVE ID already exists in tweeted_cve.txt
def finder():
    cve_id, cve_description = setranditems()
    if check_if_string_in_file('tweeted_cve.txt', cve_id):
        logger.write(timestamp + " " + cve_id + " has already been tweeted. Trying again...\n")
        finder()
    else:
        logger.write(timestamp + " " + cve_id + " has not been tweeted. Searching details...\n")
        cve_search(cve_id, cve_description)


# See if the CVE is reserved
def cve_search(cve_id, cve_description):
    if "** RESERVED **" in cve_description:
        logger.write(timestamp + " " + cve_id + " is reserved. Trying another CVE...\n")
        finder()
    else:
        logger.write(timestamp + " Creating tweet for " + cve_id + ".\n")
        tweet_cve(cve_id, cve_description)


# Tweet
def tweet_cve(cve_id, cve_description):

    # Create tweet parameters
    cve_link = web_link + cve_id
    tweet_head = cve_id + ":\n\n" + cve_description
    tweet_tail = "@CVE_A_DAY Learn more: " + cve_link
    to_tweet = tweet_breaker(tweet_head)

    # Tweet the first part
    logger.write(timestamp + " Attempting to tweet " + cve_id + ".\n")
    api.update_status(to_tweet[0])
    tweet_status_start = api.user_timeline()

    # Get the ID of the most recent tweet and subtweet below it
    for i in to_tweet[1:]:
        in_reply_to_status_id = api.user_timeline()[0].id
        api.update_status(i, in_reply_to_status_id, auto_populate_reply_metadata)
    in_reply_to_status_id = api.user_timeline()[0].id;
    # Tweet the tweet_tail
    api.update_status(tweet_tail, in_reply_to_status_id, auto_populate_reply_metadata)

    # Latest Tweet
    tweet_status_end = api.user_timeline()

    # Validate start of tweet
    if cve_id in tweet_status_start:
        logger.write(timestamp + " " + cve_id + " Successfully started tweet!\n")
        tweeted.write(cve_id)
    else:
        text = ("ERROR! Cannot validate start of tweet: " + cve_id)
        # api.send_direct_message(recipient_id, text)
        logger.write(timestamp + " ERROR! Cannot validate start of tweet: " + cve_id + ".\n")

    # Validate end of tweet
    if tweet_tail in tweet_status_end:
        logger.write(timestamp + " " + cve_id + "Successfully finished tweet!\n")
        tweeted.write(cve_id)
    else:
        text = ("ERROR! Cannot validate end of tweet: " + cve_id)
        # api.send_direct_message(recipient_id, text)
        logger.write(timestamp + " ERROR! Cannot validate end of tweet: " + cve_id + ".\n")


# Run it all
finder()
